// Задаем переменные
n = 6
T_0 = 1.41
K = 1.03
T_1 = 0
T_i = 9.2

// Задаем передаточную функцию
s = poly(0, 's')
W_2 = 1 / (1 + s * T_0)^n
W_1 = (1 + 1 / (T_i * s)) * K * W_2

W = W_1 / (1 + W_1)

// Создаем запись непрерывной системы
Sys = syslin('c', W)
// Задаем шаг в секундах
h = 1
// Дискретизируем
Sysd = dscr(Sys, h);

// Строим дискретный временной промежуток
k = [0:h:100]

// Задаем начальные значения
// v не сохраняем, поэтому можно его прямо в цикле обновлять
v = zeros(Sysd.B)
// x запоминаем для последующей визуализации результата
// и подсчета ошибок
x = zeros(k)

// Обновляем значения v и x на всем дискретном отрезке
for i = 1:length(k)
    // сначала обновляем x(i), чтобы x(i) считался по v[k],
    // а не по v[k+1] 
    x(i) = Sysd.C * v
    // Обновляем v: v[k] -> v[k+1] с учетом того, что u[k] = 1
    v = Sysd.A * v + Sysd.B
end

// Выводим переходную характеристику дискретного аналога
plot(k, x, 'blue')

// Загружаем данные с MicroCap
data = fscanfMat("C:\Users\slava\OneDrive\Рабочий стол\OUT4\lab3_pi.TNO")

// Визуализируем данные из MicroCap
plot(data(:, 1), data(:, 2), 'red')

// Подготавливаем начальные данные для подсчета ошибок
err = 0
tau = h * 1000
y = data(:, 2)

for i = 2:length(k)
    err = err + (y((i-1) * tau) - x(i))^2
end

err = sqrt(err / length(k))
disp(err)
